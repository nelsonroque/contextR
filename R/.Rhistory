# set API key
DARK_SKY_API_KEY = "001ef0b8cd273a1551d5abe38a4b26a2"
# ///////////////////////////////////////////////////////////////////////////////
# create demo table of api calls to make
geo.df <- data.frame(neg_affect = c(90,80),
dob = c("1991-05-16","1991-04-04"),
lat = c(40.7788,39.7788),
lng = c(-77.84137,-77.84137),
ts = c(1273687200,1273687200)) %>%
mutate(og_date = lubridate::as_datetime(ts)) %>%
mutate(lat_lng = create_lat_lng_str(lat,lng),
zodiac = get_zodiac_sign_from_dob(dob),
birth_season = get_season_from_date_v(dob),
current_season = get_season_from_date_v(og_date),
api_call = create_darksky_api_call_v(DARK_SKY_API_KEY, lat, lng, ts)) %>%
mutate(api_call_id = hash_api_call_v(api_call, algo="md5")) %>%
mutate(lunar_result = purrr::pmap(list(dob), get_lunar_context_from_date)) %>%
unnest(lunar_result)
# UP TO THIS POINT, ALL CONTEXT IS FREE, GOING FORWARD, see:
# -= DARKSKY API PRICING: https://darksky.net/dev
# -= CENSUS API RESTRICTIONS: https://cran.r-project.org/web/packages/censusapi/vignettes/getting-started.html
# ///////////////////////////////////////////////////////////////////////////////
# wrapper of lat_lng:lunar_result
# ts
# lat
# lng
# dob
# og_date
# FUNCTION: get data from api (operates off a table of API calls)
get_weather_context <- function(api_call, hash="md5"){
# create blank dataframes
daily.results <- data.frame()
hourly.results <- data.frame()
minutely.results <- data.frame()
currently.results <- data.frame()
alerts.results <- data.frame()
for(i in 1:length(api_call)){
raw.json <- jsonlite::fromJSON(api_call[i])
# daily
daily.df <- tibble::as_tibble(raw.json$daily$data) %>%
mutate(api_call = api_call[i]) %>%
mutate(api_call_id = digest::digest(api_call, algo=hash)) # save MD5 of call
daily.results <- bind_rows(daily.results, daily.df)
# hourly
hourly.df <- tibble::as_tibble(raw.json$hourly$data) %>%
mutate(api_call = api_call[i]) %>%
mutate(api_call_id = digest::digest(api_call, algo=hash)) # save MD5 of call
hourly.results <- bind_rows(hourly.results, hourly.df)
# minutely
minutely.df <- tibble::as_tibble(raw.json$minutely$data) %>%
mutate(api_call = api_call[i]) %>%
mutate(api_call_id = digest::digest(api_call, algo=hash)) # save MD5 of call
minutely.results <- bind_rows(minutely.results, minutely.df)
# current
currently.df <- tibble::as_tibble(raw.json$currently$data) %>%
mutate(api_call = api_call[i]) %>%
mutate(api_call_id = digest::digest(api_call, algo=hash)) # save MD5 of call
currently.results <- bind_rows(currently.results, currently.df)
# alerts
alerts.df <- tibble::as_tibble(raw.json$alerts$data) %>%
mutate(api_call = api_call[i]) %>%
mutate(api_call_id = digest::digest(api_call, algo=hash)) # save MD5 of call
alerts.results <- bind_rows(alerts.results, alerts.df)
}
return(context=list(daily=daily.results,
minutely=minutely.results,
hourly=hourly.results,
currently=currently.results,
alerts=alerts.results))
}
# FUNCTION: get data from api (operates off a table of API calls)
get_weather_context <- function(api_call, hash="md5"){
# create blank dataframes
daily.results <- data.frame()
hourly.results <- data.frame()
minutely.results <- data.frame()
currently.results <- data.frame()
alerts.results <- data.frame()
for(i in 1:length(api_call)){
raw.json <- jsonlite::fromJSON(api_call[i])
# daily
daily.df <- tibble::as_tibble(raw.json$daily$data) %>%
mutate(api_call = api_call[i]) %>%
mutate(api_call_id = digest::digest(api_call, algo=hash)) # save MD5 of call
daily.results <- bind_rows(daily.results, daily.df)
# hourly
hourly.df <- tibble::as_tibble(raw.json$hourly$data) %>%
mutate(api_call = api_call[i]) %>%
mutate(api_call_id = digest::digest(api_call, algo=hash)) # save MD5 of call
hourly.results <- bind_rows(hourly.results, hourly.df)
# minutely
minutely.df <- tibble::as_tibble(raw.json$minutely$data) %>%
mutate(api_call = api_call[i]) %>%
mutate(api_call_id = digest::digest(api_call, algo=hash)) # save MD5 of call
minutely.results <- bind_rows(minutely.results, minutely.df)
# current
currently.df <- tibble::as_tibble(raw.json$currently$data) %>%
mutate(api_call = api_call[i]) %>%
mutate(api_call_id = digest::digest(api_call, algo=hash)) # save MD5 of call
currently.results <- bind_rows(currently.results, currently.df)
# alerts
alerts.df <- tibble::as_tibble(raw.json$alerts$data) %>%
mutate(api_call = api_call[i]) %>%
mutate(api_call_id = digest::digest(api_call, algo=hash)) # save MD5 of call
alerts.results <- bind_rows(alerts.results, alerts.df)
}
return(context=list(daily=daily.results,
minutely=minutely.results,
hourly=hourly.results,
currently=currently.results,
alerts=alerts.results))
}
# UP TO THIS POINT, ALL CONTEXT IS FREE, GOING FORWARD, see:
# -= DARKSKY API PRICING: https://darksky.net/dev
weather.df <- get_weather_context(geo.df$api_call)
weather.df$daily
weather.df$minutely
weather.df$hourly
weather.list <- weather.df
weather.daily <- weather.list$daily %>% setNames(names(.) %>% str_replace_all("(?", "_\\1") %>% str_to_lower())
weather.daily <- weather.list$daily %>% setNames(names(.) %>% str_replace_all("''(?", "_\\1") %>% str_to_lower())
weather.daily <- weather.list$daily %>% setNames(names(.) %>% str_replace_all(''(?, "_\\1") %>% str_to_lower())
weather.daily <- weather.list$daily %>% setNames(names(.) %>% str_replace_all(''(?'', "_\\1") %>% str_to_lower())
f
weather.daily <- weather.list$daily %>% setNames(names(.) %>% str_replace_all('(?', "_\\1") %>% str_to_lower())
weather.daily <- weather.list$daily %>%
rename_all(
funs(
stringr::str_to_lower(.) %>%
stringr::str_replace_all(., '\\.', '_')
)
)
View(weather.daily)
weather.daily <- weather.list$daily %>%
sanitize_cols <- function(df) {
df %>% rename_all(
funs(
stringr::str_to_lower(.) %>%
stringr::str_replace_all(., '\\.', '_')
)
)
}
weather.daily <- weather.list$daily %>%
sanitize_cols <- function(df) {
df %>% rename_all(
funs(
stringr::str_to_lower(.) %>%
stringr::str_replace_all(., '\\.', '_')
)
)
}
weather.daily <- weather.list$daily %>%
sanitize_cols(.)
df <- df %>% rename_all(
funs(
stringr::str_to_lower(.) %>%
stringr::str_replace_all(., '\\.', '_')
)
)
return(rdf)
# FUNCTION: get data from api (operates off a table of API calls)
get_weather_context <- function(api_call, hash="md5"){
# POWERED BY DARKSKY: (https://darksky.net/poweredby)
# FOR API INFORMATION, SEE (https://darksky.net/dev/docs#time-machine-request)
# create blank dataframes
daily.results <- data.frame()
hourly.results <- data.frame()
minutely.results <- data.frame()
currently.results <- data.frame()
alerts.results <- data.frame()
for(i in 1:length(api_call)){
raw.json <- jsonlite::fromJSON(api_call[i])
# daily
daily.df <- tibble::as_tibble(raw.json$daily$data) %>%
mutate(api_call = api_call[i]) %>%
mutate(api_call_id = digest::digest(api_call, algo=hash)) # save MD5 of call
daily.results <- bind_rows(daily.results, daily.df)
# hourly
hourly.df <- tibble::as_tibble(raw.json$hourly$data) %>%
mutate(api_call = api_call[i]) %>%
mutate(api_call_id = digest::digest(api_call, algo=hash)) # save MD5 of call
hourly.results <- bind_rows(hourly.results, hourly.df)
# minutely
minutely.df <- tibble::as_tibble(raw.json$minutely$data) %>%
mutate(api_call = api_call[i]) %>%
mutate(api_call_id = digest::digest(api_call, algo=hash)) # save MD5 of call
minutely.results <- bind_rows(minutely.results, minutely.df)
# current
currently.df <- tibble::as_tibble(raw.json$currently$data) %>%
mutate(api_call = api_call[i]) %>%
mutate(api_call_id = digest::digest(api_call, algo=hash)) # save MD5 of call
currently.results <- bind_rows(currently.results, currently.df)
# alerts
alerts.df <- tibble::as_tibble(raw.json$alerts$data) %>%
mutate(api_call = api_call[i]) %>%
mutate(api_call_id = digest::digest(api_call, algo=hash)) # save MD5 of call
alerts.results <- bind_rows(alerts.results, alerts.df)
}
return(context=list(daily=daily.results,
minutely=minutely.results,
hourly=hourly.results,
currently=currently.results,
alerts=alerts.results))
}
weather.daily <- weather.list$daily %>% rename_all(
funs(
stringr::str_to_lower(.) %>%
stringr::str_replace_all(., '\\.', '_')
)
)
View(weather.daily)
weather.daily <- weather.list$daily %>% rename_all(
funs(
stringr::str_to_lower(.) %>%
stringr::str_replace_all(., '\\.', '_')
) %>%
inner_join(geo.df)
)
funs(
stringr::str_to_lower(.) %>%
stringr::str_replace_all(., '\\.', '_')
)) %>%
inner_join(geo.df)
weather.daily <- weather.list$daily %>% rename_all(
funs(
stringr::str_to_lower(.) %>%
stringr::str_replace_all(., '\\.', '_')
))
og.plus.weather.daily <- weather.daily %>%
inner_join(geo.df)
View(og.plus.weather.daily)
sanitize_cols <- function(df) {
rdf <- df
return(rdf)
}
get_lunar_context_from_date <- function(date, ...){
# if date provided is not a valid date, make it one [TODO: expose `format`]
if(class(date) != "Date"){
date <- as.Date(date, format="%Y-%m-%d")
}
# extract lunar data (no API -- this is cheap)
lunar_phase_radians <- lunar::lunar.phase(date)
lunar_phase_4cat <- lunar::lunar.phase(date,name=4)
lunar_phase_8cat <- lunar::lunar.phase(date,name=8)
lunar_distance_cat <- lunar::lunar.distance(date,name=T)
lunar_distance_num <- lunar::lunar.distance(date,name=F)
lunar_illumination <- lunar::lunar.illumination(date)
# return as a tibble for niceties
return(tibble::tibble(lunar_phase_radians,
lunar_phase_4cat,
lunar_phase_8cat,
lunar_distance_cat,
lunar_distance_num,
lunar_illumination))
}
get_lunar_context_from_date_v <- Vectorize(get_lunar_context_from_date)
weather.daily <- weather.list$daily %>% rename_all(
funs(
stringr::str_to_lower(.) %>%
stringr::str_replace_all(., '\\.', '_')
))
og.plus.weather.daily <- weather.daily %>%
inner_join(geo.df)
# create demo table of api calls to make
geo.df <- data.frame(neg_affect = c(90,80),
dob = c("1991-05-16","1991-04-04"),
lat = c(40.7788,39.7788),
lng = c(-77.84137,-77.84137),
ts = c(1273687200,1273687200)) %>%
mutate(og_date = lubridate::as_datetime(ts)) %>%
mutate(lat_lng = create_lat_lng_str(lat,lng),
zodiac = get_zodiac_sign_from_dob(dob),
birth_season = get_season_from_date_v(dob),
current_season = get_season_from_date_v(og_date),
api_call = create_darksky_api_call_v(DARK_SKY_API_KEY, lat, lng, ts)) %>%
mutate(api_call_id = hash_api_call_v(api_call, algo="md5")) %>%
mutate(lunar_result = purrr::pmap(list(dob), get_lunar_context_from_date)) %>%
unnest(lunar_result)
weather.daily <- weather.list$daily %>% rename_all(
funs(
stringr::str_to_lower(.) %>%
stringr::str_replace_all(., '\\.', '_')
))
og.plus.weather.daily <- weather.daily %>%
inner_join(geo.df)
View(og.plus.weather.daily)
# FUNCTION: get data from api (operates off a table of API calls)
get_weather_context <- function(api_call, hash="md5"){
# POWERED BY DARKSKY: (https://darksky.net/poweredby)
# FOR API INFORMATION, SEE (https://darksky.net/dev/docs#time-machine-request)
# create blank dataframes
daily.results <- data.frame()
hourly.results <- data.frame()
minutely.results <- data.frame()
currently.results <- data.frame()
alerts.results <- data.frame()
for(i in 1:length(api_call)){
raw.json <- jsonlite::fromJSON(api_call[i])
# daily
daily.df <- tibble::as_tibble(raw.json$daily$data) %>%
mutate(api_call = api_call[i]) %>%
mutate(api_call_id = digest::digest(api_call, algo=hash)) # save MD5 of call
daily.results <- bind_rows(daily.results, daily.df)
# hourly
hourly.df <- tibble::as_tibble(raw.json$hourly$data) %>%
mutate(api_call = api_call[i]) %>%
mutate(api_call_id = digest::digest(api_call, algo=hash)) # save MD5 of call
hourly.results <- bind_rows(hourly.results, hourly.df)
# minutely
minutely.df <- tibble::as_tibble(raw.json$minutely$data) %>%
mutate(api_call = api_call[i]) %>%
mutate(api_call_id = digest::digest(api_call, algo=hash)) # save MD5 of call
minutely.results <- bind_rows(minutely.results, minutely.df)
# current
currently.df <- tibble::as_tibble(raw.json$currently$data) %>%
mutate(api_call = api_call[i]) %>%
mutate(api_call_id = digest::digest(api_call, algo=hash)) # save MD5 of call
currently.results <- bind_rows(currently.results, currently.df)
# alerts
alerts.df <- tibble::as_tibble(raw.json$alerts$data) %>%
mutate(api_call = api_call[i]) %>%
mutate(api_call_id = digest::digest(api_call, algo=hash)) # save MD5 of call
alerts.results <- bind_rows(alerts.results, alerts.df)
}
return(context=list(daily=daily.results,
minutely=minutely.results,
hourly=hourly.results,
currently=currently.results,
alerts=alerts.results))
}
get_lunar_context_from_date <- function(date, ...){
# if date provided is not a valid date, make it one [TODO: expose `format`]
if(class(date) != "Date"){
date <- as.Date(date, format="%Y-%m-%d")
}
# extract lunar data (no API -- this is cheap)
lunar_phase_radians <- lunar::lunar.phase(date)
lunar_phase_4cat <- lunar::lunar.phase(date,name=4)
lunar_phase_8cat <- lunar::lunar.phase(date,name=8)
lunar_distance_cat <- lunar::lunar.distance(date,name=T)
lunar_distance_num <- lunar::lunar.distance(date,name=F)
lunar_illumination <- lunar::lunar.illumination(date)
# return as a tibble for niceties
return(tibble::tibble(lunar_phase_radians,
lunar_phase_4cat,
lunar_phase_8cat,
lunar_distance_cat,
lunar_distance_num,
lunar_illumination))
}
get_lunar_context_from_date_v <- Vectorize(get_lunar_context_from_date)
get_season_from_date <- function(date, hemi="northern", use_pkg = T){
if(use_pkg){
season <- tolower(lunar::terrestrial.season(as.Date(date)))
} else {
if(hemi == "northern") {
if(lubridate::month(date) == 12 | lubridate::month(date) == 1 | lubridate::month(date) == 2){
season <- "winter"
}
if(lubridate::month(date) == 3 | lubridate::month(date) == 4 | lubridate::month(date) == 5){
season <- "spring"
}
if(lubridate::month(date) == 6 | lubridate::month(date) == 7 | lubridate::month(date) == 8){
season <- "summer"
}
if(lubridate::month(date) == 9 | lubridate::month(date) == 10 | lubridate::month(date) == 11){
season <- "autumn"
}
} else {
if(hemi != "northern") {
if(lubridate::month(date) == 12 | lubridate::month(date) == 1 | lubridate::month(date) == 2){
season <- "summer"
}
if(lubridate::month(date) == 3 | lubridate::month(date) == 4 | lubridate::month(date) == 5){
season <- "autumn"
}
if(lubridate::month(date) == 6 | lubridate::month(date) == 7 | lubridate::month(date) == 8){
season <- "winter"
}
if(lubridate::month(date) == 9 | lubridate::month(date) == 10 | lubridate::month(date) == 11){
season <- "spring"
}
}
}
}
return(season)
}
get_season_from_date_v <- Vectorize(get_season_from_date)
get_zodiac_sign_from_dob <- function(dob){
return(tolower(DescTools::Zodiac(dob)))
}
create_lat_lng_str <- function(lat,lng,delimiter=","){
return(paste(lat,lng,sep=delimiter))
}
hash_api_call <- function(api_call, algo="md5") {
return(digest::digest(api_call, algo=algo))
}
hash_api_call_v <- Vectorize(hash_api_call)
create_darksky_api_call <- function(DARK_SKY_API_KEY, lat, lng, ts) {
base_call = "https://api.darksky.net/forecast/"
var_call = paste0("/", lat, ",", lng, ",", ts)
api_call = paste0(base_call, DARK_SKY_API_KEY, var_call)
return(api_call)
}
create_darksky_api_call_v <- Vectorize(create_darksky_api_call)
detach(digest)
detach('digest')
# load packages
library(tidyverse)
library(DescTools) # zodiac dependency
library(lunar) # all lunar data outside of darksky
library(digest) #
library(jsonlite)
# ///////////////////////////////////////////////////////////////////////////////
# set API key
DARK_SKY_API_KEY = "001ef0b8cd273a1551d5abe38a4b26a2"
# ///////////////////////////////////////////////////////////////////////////////
# create demo table of minimum necessary features
og.df <- data.frame(survey_result = c(90,80), # example of 'real data'
dob = c("1991-05-16","1991-04-04"), # optional
lat = c(40.7788,39.7788), # necessary for getting weather (see conversions)
lng = c(-77.84137,-77.84137), # necessary for getting weather (see conversions)
ts = c(1273687200,1273687200)) %>% # necessary for getting weather (see conversions)
mutate(og_date = lubridate::as_datetime(ts)) # make sure to have ts in as.Date format for other calls
# ///////////////////////////////////////////////////////////////////////////////
# pull 'free' context, and prepare darksky API calls, just in case
context.df <- og.df %>%
mutate(lat_lng = create_lat_lng_str(lat,lng),
zodiac = get_zodiac_sign_from_dob(dob),
birth_season = get_season_from_date_v(dob),
current_season = get_season_from_date_v(og_date),
api_call = create_darksky_api_call_v(DARK_SKY_API_KEY, lat, lng, ts)) %>%
mutate(api_call_id = hash_api_call_v(api_call, algo="md5")) %>%
mutate(lunar_result = purrr::pmap(list(dob), get_lunar_context_from_date)) %>%
unnest(lunar_result)
# ///////////////////////////////////////////////////////////////////////////////
# UP TO THIS POINT, ALL CONTEXT IS FREE
# ///////////////////////////////////////////////////////////////////////////////
# GOING FORWARD, see:
# -= DARKSKY API PRICING: https://darksky.net/dev
# get all weather data for each api call (returns list)
weather.list <- get_weather_context(context.df$api_call)
# extract daily data
weather.daily <- weather.list$daily %>% rename_all(
funs(
stringr::str_to_lower(.) %>%
stringr::str_replace_all(., '\\.', '_')
))
# stitch it!
og.plus.weather.daily <- weather.daily %>%
inner_join(context.df)
# -= CENSUS API RESTRICTIONS: https://cran.r-project.org/web/packages/censusapi/vignettes/getting-started.html
# ///////////////////////////////////////////////////////////////////////////////
# wrapper of lat_lng:lunar_result
# ts
# lat
# lng
# dob
# og_date
# load packages
library(tidyverse) # for everything dplyr
library(DescTools) # zodiac dependency
library(lunar) # all lunar data outside of darksky
library(digest) # for hashing API to create unique key for merging
library(jsonlite) # for interpreting JSON
# ///////////////////////////////////////////////////////////////////////////////
# set API key
DARK_SKY_API_KEY = "001ef0b8cd273a1551d5abe38a4b26a2"
# ///////////////////////////////////////////////////////////////////////////////
# create demo table of minimum necessary features
og.df <- data.frame(survey_result = c(90,80), # example of 'real data'
dob = c("1991-05-16","1991-04-04"), # optional
lat = c(40.7788,39.7788), # necessary for getting weather (see conversions)
lng = c(-77.84137,-77.84137), # necessary for getting weather (see conversions)
ts = c(1273687200,1273687200)) %>% # necessary for getting weather (see conversions)
mutate(og_date = lubridate::as_datetime(ts)) # make sure to have ts in as.Date format for other calls
# ///////////////////////////////////////////////////////////////////////////////
# pull 'free' context, and prepare darksky API calls, just in case
context.df <- og.df %>%
mutate(lat_lng = create_lat_lng_str(lat,lng),
zodiac = get_zodiac_sign_from_dob(dob),
birth_season = get_season_from_date_v(dob),
current_season = get_season_from_date_v(og_date),
api_call = create_darksky_api_call_v(DARK_SKY_API_KEY, lat, lng, ts)) %>%
mutate(api_call_id = hash_api_call_v(api_call, algo="md5")) %>%
mutate(lunar_result = purrr::pmap(list(dob), get_lunar_context_from_date)) %>%
unnest(lunar_result)
# ///////////////////////////////////////////////////////////////////////////////
# UP TO THIS POINT, ALL CONTEXT IS FREE
# ///////////////////////////////////////////////////////////////////////////////
# GOING FORWARD, see:
# -= DARKSKY API PRICING: https://darksky.net/dev
# get all weather data for each api call (returns list)
weather.list <- get_weather_context(context.df$api_call)
# extract daily data
weather.daily <- weather.list$daily %>% rename_all(
funs(
stringr::str_to_lower(.) %>%
stringr::str_replace_all(., '\\.', '_')
))
# stitch it!
og.plus.weather.daily <- weather.daily %>%
inner_join(context.df)
# -= CENSUS API RESTRICTIONS: https://cran.r-project.org/web/packages/censusapi/vignettes/getting-started.html
# ///////////////////////////////////////////////////////////////////////////////
# wrapper of lat_lng:lunar_result
# ts
# lat
# lng
# dob
# og_date
View(og.plus.weather.daily)
